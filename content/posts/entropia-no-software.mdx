---
title: 'Entropia no software e a teoria da Janela Quebrada'
date: '2023-06-19'
description: 'Salvando o artigo "Entropia no software e a teoria da janela quebrada: Como afeta seu dia a dia?" de Rafael dos Santos Miguel Filho.'
category: 'Article'
tags: 'programming, management, architecture, filosofia, Clean Code, structure, productivity, project, archive'
author: 'mateusfg7'
status: 'published'
---


# Introdu√ß√£o

<Warn>
Essa √© apenas uma transcri√ß√£o/arquivo do artigo ["Entropia no software e a teoria da janela quebrada: Como afeta seu dia a dia?"](https://chroniclesofapragmaticprogrammer.substack.com/p/entropia-no-software-e-a-teoria-da) de [Rafael dos Santos Miguel Filho](https://substack.com/@chroniclesofapragmaticprogrammer), que achei v√°lido traze-lo aqui pela sua grande utilidade e import√¢ncia. Portanto **nada do artigo a seguir foi escrito por mim**.
</Warn>

Sim, voc√™ ouviu direito: _Entropia no Software e a Teoria da Janela Quebrada_. Pode parecer um pouco estranho no come√ßo, talvez at√© esteja se perguntando "mas o que esses conceitos t√™m a ver com o mundo do software?". Esses dois conceitos n√£o s√£o termos comumente associados um ao outro, mas ao explorar mais a fundo, descobrimos que essas duas teorias podem oferecer uma perspectiva √∫nica sobre a gest√£o eficaz do desenvolvimento e manuten√ß√£o de software. Neste artigo, exploramos como esses dois conceitos se inter-relacionam e como podem ser utilizados para melhorar as pr√°ticas de desenvolvimento de software.

# Entropia

Parece um termo cient√≠fico complicado, n√£o √©? N√£o se preocupe, juntos vamos desmistificar essa palavra e entender o que ela realmente significa, especialmente quando aplicada ao mundo do software. Pegue um caf√© e vamos l√°! ‚òï

Vamos come√ßar no s√©culo XIX (19), com um cientista chamado [_Rudolf Clausius_](https://pt.wikipedia.org/wiki/Rudolf_Clausius). Foi ele quem nos apresentou a entropia no mundo da termodin√¢mica. Mas como isso pode ser comparado ao desenvolvimento de software? Prometo que vamos chegar l√°, mas antes vamos entender um pouco mais sobre o que Clausius queria dizer com entropia.

Entropia, no campo da f√≠sica, **√© uma forma de medir a imprevisibilidade ou, como alguns preferem simplificar, a "desordem" dentro de um sistema**. Agora, quando falo em "desordem", n√£o quero dizer bagun√ßa no sentido comum da palavra. Na verdade, estou falando sobre como a energia est√° distribu√≠da em um sistema.

Imagine que temos uma caixa cheia de part√≠culas. Se todas essas part√≠culas estiverem concentradas em um √∫nico canto, podemos dizer que a entropia √© baixa - h√° uma certa "ordem". Mas, se as part√≠culas est√£o espalhadas de maneira aleat√≥ria por toda a caixa, a√≠ temos uma alta entropia - a distribui√ß√£o de energia √© mais "imprevis√≠vel" ou "desordenada". A natureza tende ao estado de maior entropia, ou seja, as part√≠culas ir√£o se dispersar, **_a menos que algo externo intervenha_**. √â como se a natureza gostasse de um pouco de imprevisibilidade

Agora, chegou a hora de conectar essa ideia com o mundo do software üåâ. **Quando falamos em entropia no desenvolvimento de software, estamos nos referindo a essa tend√™ncia natural dos sistemas de software de se tornarem mais complexos e "desordenados" com o passar do tempo**. E quando falo "desordem" aqui, estou falando de coisas como c√≥digo mal estruturado, documenta√ß√£o insuficiente, bugs n√£o corrigidos, _code smells_, e por a√≠ vai.

O que acontece √© que conforme o software cresce e evolui, √© preciso esfor√ßo constante para evitar que essa entropia aumente. Precisamos trabalhar para manter o sistema organizado e eficiente - similar a como as part√≠culas na caixa necessitam de uma for√ßa externa para n√£o se espalharem aleatoriamente.

Agora que entendemos rapidamente o que √© entropia, vamos entender alguns pontos que podem contribuir para o seu aumento dentro do software. Vou aproveitar essa parte para comentar algumas que, infelizmente, j√° presenciei tamb√©m na ind√∫stria de software.

# A falta de requisitos claros!

Vou compartilhar com voc√™ uma hist√≥ria que, apesar de fict√≠cia, poderia facilmente se passar na realidade de muitas equipes de desenvolvimento de software. Prometo que √© uma hist√≥ria com uma li√ß√£o valiosa para todos n√≥s: programadores, gerentes de projeto, product owners e qualquer um interessado em construir produtos de software de sucesso.

Pense em uma startup inovadora que est√° desenvolvendo um aplicativo de entrega de alimentos. Entre os muitos recursos desse aplicativo, surge um requisito especial: a op√ß√£o de os usu√°rios compartilharem um pedido com amigos, permitindo que todos adicionem seus itens preferidos √† mesma ordem. Isso parece um diferencial competitivo incr√≠vel, n√£o √© mesmo?

No entanto, a descri√ß√£o desse requisito √© um pouco vaga e n√£o entra em detalhes sobre como essa funcionalidade deve ser implementada. Deve existir um limite de usu√°rios por pedido compartilhado? Como lidar com a divis√£o dos custos de entrega?

Nosso time de desenvolvimento, sempre buscando a efici√™ncia, interpreta o requisito da melhor forma poss√≠vel com as informa√ß√µes dispon√≠veis. Eles decidem que n√£o haver√° limites para a quantidade de usu√°rios em um pedido compartilhado, e que os custos de entrega ser√£o divididos igualmente entre todos os participantes.

Quando o recurso √© lan√ßado, a rea√ß√£o dos usu√°rios √© mista. Alguns adoram a ideia, mas outros ficam frustrados. Eles n√£o acham justo que um usu√°rio que adicionou apenas um item pequeno pague a mesma taxa de entrega de algu√©m que pediu v√°rios itens maiores. A falta de limites tamb√©m causa problemas, com pedidos gigantescos causando atrasos nas entregas.

A li√ß√£o aqui? Requisitos mal definidos podem levar a mal-entendidos, **implementa√ß√µes imprecisas** e at√© mesmo a um feedback negativo dos usu√°rios.

Portanto, **cada vez que um novo recurso √© proposto, √© fundamental n√£o aceitarmos requisitos que pare√ßam insuficientemente detalhados ou que n√£o estejam coerentes com a realidade**. Esse √© um dever compartilhado: a equipe de especialistas do dom√≠nio deve se esfor√ßar para esclarecer as funcionalidades, enquanto os gestores de tecnologia precisam estar prontos para questionar e clarificar qualquer requisito que pare√ßa vago.

_**E como isso afeta e colabora para a alta desordem do software?**_

Quando um recurso √© implementado com base em requisitos mal definidos, pode levar a um c√≥digo mal estruturado ou a uma _**arquitetura de software que n√£o est√° alinhada com a verdadeira necessidade do neg√≥cio**_. Isso pode causar problemas, como dificuldades de manuten√ß√£o, problemas de performance e at√© a introdu√ß√£o de bugs. Al√©m disso, se os desenvolvedores precisam revisitar continuamente o recurso para corrigir mal-entendidos ou implementar mudan√ßas, isso pode causar ainda mais complexidade e "desordem".

Isso gera estresse para a equipe. Afinal, provavelmente recursos que n√£o foram planejados corretamente precisam de novas defini√ß√µes e modelagem de dados. Talvez novas tabelas precisem ser criadas, novos relacionamentos e entidades. Isso consequentemente pode gerar prazos de entregas irrealistas para correr atr√°s do preju√≠zo. Sabemos que muitas empresas deixam de lado em momentos cr√≠ticos a qualidade, muitos recursos novos ou at√© os j√° existentes podem precisar de uma revis√£o completa, **mas isso n√£o √© feito com qualidade**. Percebe a cascata de problemas gerados? **Isso √© a desordem**!

Portanto, requisitos mal definidos aumentam a entropia tanto no software quanto no neg√≥cio. Eles contribuem para um c√≥digo mais ca√≥tico e complexo e podem levar a resultados de neg√≥cios indesejados. Ao mesmo tempo, lidar com esses requisitos e suas consequ√™ncias demanda tempo e recursos, que poderiam ser usados para criar novos recursos ou melhorar outros aspectos do sistema. √â por isso que √© t√£o importante se esfor√ßar para definir claramente os requisitos desde o in√≠cio.

# M√° Comunica√ß√£o entre equipes!

Vamos explorar um outro cen√°rio bastante comum no mundo do desenvolvimento de software. Este √© especialmente relevante se voc√™ j√° fez parte de uma equipe de desenvolvimento.

Vamos visualizar uma startup, trabalhando em um aplicativo de rede social. Temos dois times, temos um desenvolvedor encarregado de construir uma [API](https://aws.amazon.com/pt/what-is/api/) que √© o cora√ß√£o do sistema de notifica√ß√£o do aplicativo, respons√°vel por alertar os usu√°rios sobre novos likes, coment√°rios e mensagens.

Por outro lado, temos outro programador, em outra equipe, cuja tarefa √© desenvolver a interface de usu√°rio (frontend) que exibir√° essas notifica√ß√µes. Este desenvolvedor depende da API para receber esses dados e exibi-los de forma intuitiva e atraente para os usu√°rios.

Agora, imagine que o desenvolvedor respons√°vel pela API, na busca pela excel√™ncia, faz algumas melhorias significativas, otimizando a forma como os dados s√£o entregues. No entanto, esquece-se de informar ao colega que depende dessa API sobre as mudan√ßas realizadas, ou sobre a nova vers√£o do servi√ßo.

O programador frontend, completamente alheio √† atualiza√ß√£o, continua a trabalhar com a vers√£o antiga da API. Quando o aplicativo √© lan√ßado, os usu√°rios come√ßam a reclamar que as notifica√ß√µes n√£o est√£o funcionando como esperado, ou at√© mesmo aparecendo de forma errada.

A situa√ß√£o acima ilustra como um simples deslize na comunica√ß√£o pode conduzir a um aumento na entropia do software. Essa disfun√ß√£o n√£o apenas introduz bugs, mas tamb√©m pode causar frustra√ß√£o e confus√£o na equipe, e pior ainda, insatisfa√ß√£o no usu√°rio final.

Portanto, a li√ß√£o aqui √© clara: **a comunica√ß√£o eficaz √© fundamental para controlar a entropia no software**. Manter todos na equipe informados sobre as mudan√ßas e atualiza√ß√µes pode evitar equ√≠vocos e garantir que todos estejam alinhados, contribuindo para um software mais eficiente e um ambiente de trabalho mais harm√¥nico.

_**E como a situa√ß√£o acima colabora para a alta desordem do software?**_

A situa√ß√£o descrita acima contribui significativamente para a alta entropia do software, ou desordem, de v√°rias maneiras. Vamos dividi-la em peda√ßos para entender melhor.

1. **C√≥digo Desatualizado ou Incompat√≠vel:** O desenvolvedor que trabalha na interface do usu√°rio est√° usando uma vers√£o desatualizada da API. Isto pode levar a inconsist√™ncias no c√≥digo, erros de compatibilidade e at√© mesmo falhas no sistema. Al√©m disso, pode haver um impacto na performance do sistema.
2. **Esfor√ßo Desnecess√°rio:** A equipe agora ter√° que gastar tempo extra corrigindo os problemas causados pela falta de comunica√ß√£o. Isso significa tempo de desenvolvimento perdido que poderia ter sido usado para adicionar novos recursos ou melhorar outros aspectos do software.
3. **Introdu√ß√£o de Bugs:** A interface do usu√°rio que depende da API desatualizada pode n√£o funcionar como esperado, levando a bugs. Dependendo da gravidade desses bugs, eles podem afetar a experi√™ncia do usu√°rio e at√© mesmo levar a perdas de dados.
4. **Insatisfa√ß√£o do Usu√°rio:** A experi√™ncia do usu√°rio pode ser prejudicada devido a funcionalidades mal implementadas ou bugs. Isso pode levar a feedback negativo, perda de usu√°rios e danos √† reputa√ß√£o do produto.

Esses fatores combinados aumentam a "desordem" ou entropia dentro do projeto de software. Eles criam uma situa√ß√£o onde a complexidade e a confus√£o dominam, dificultando a implementa√ß√£o de melhorias e corre√ß√µes. √â por isso que a boa comunica√ß√£o √© t√£o crucial!

# Mudan√ßas frequentes nos requisitos!

Imagino que voc√™ j√° tenha se deparado com uma situa√ß√£o onde os requisitos para um software mudam constantemente, certo? Isso pode ser um grande desafio. Tais mudan√ßas podem incluir novas funcionalidades, requisitos e processos que n√£o foram considerados inicialmente. E o que isso causa? Aumento na complexidade do software, introdu√ß√£o de bugs e dificuldade para manter e evoluir o sistema.

Para ilustrar, vamos imaginar um programador desenvolvendo um software de gerenciamento de estoque. Durante o desenvolvimento, os requisitos est√£o em constante mudan√ßa: novos tipos de produtos s√£o introduzidos, regras de desconto s√£o alteradas e as informa√ß√µes dos produtos s√£o variadas. Essa constante adapta√ß√£o √†s mudan√ßas pode resultar em uma arquitetura de software incerta e em constante fluxo.

Essa falta de estabilidade e clareza aumenta a entropia dentro do software. A fase de planejamento parece nunca chegar a uma conclus√£o definitiva, enquanto a lista de requisitos cresce e se transforma. A adi√ß√£o de caminhos de c√≥digo desnecess√°rios ou redundantes, em resposta a essas mudan√ßas frequentes, pode levar a uma complexidade ainda maior, dificultando a compreens√£o do c√≥digo e sua manuten√ß√£o.

Al√©m disso, com cada nova mudan√ßa, h√° um risco maior de introduzir bugs e falhas no software. Afinal, cada altera√ß√£o requer uma revis√£o cuidadosa e testes completos para garantir que n√£o est√° introduzindo novos problemas. Infelizmente, com prazos apertados e requisitos mal definidos, essa etapa crucial pode ser negligenciada, o que s√≥ aumenta a entropia do sistema.

Por fim, o que isso tudo tem a ver com o c√≥digo que escrevemos? Bem, tudo! Quanto mais complexo o sistema se torna, mais dif√≠cil √© para n√≥s, desenvolvedores, entender e manter o c√≥digo. Vamos conversar mais sobre esse assunto.

# O c√≥digo indesejado

A falta de di√°logo entre as equipes, a falta de especifica√ß√µes claras e as mudan√ßas frequentes nos requisitos podem impactar negativamente a forma como escrevemos c√≥digo de v√°rias maneiras:

Vamos come√ßar com o **C√≥digo inconsistente**. Imagine uma equipe de desenvolvedores trabalhando em um projeto, mas com uma comunica√ß√£o prec√°ria entre si. Isso pode resultar em diferentes interpreta√ß√µes dos requisitos e, portanto, inconsist√™ncias no c√≥digo.

Agora, pense no **C√≥digo mal mantido**. Especifica√ß√µes nebulosas e mudan√ßas constantes podem levar a um emaranhado de c√≥digo "sujo", semelhante a um pr√©dio mal conservado, que se torna cada vez mais dif√≠cil de manter.

Em seguida, temos os chamados "**cheiros de c√≥digo**". Pense que est√° andando por uma rua e sente um odor desagrad√°vel. √â um sinal de que algo n√£o est√° limpo. No nosso c√≥digo, os famosos [_code smells_](https://refactoring.guru/refactoring/smells), s√£o aspectos que sugerem **problemas potenciais de qualidade ou design**, geralmente provocados por mudan√ßas frequentes nos requisitos ou at√© mesmo falta de experiencia dos programadores, falta de ado√ß√£o de boas pr√°ticas entre outros fatores ligados a legibilidade do c√≥digo.

**C√≥digo redundante** tamb√©m √© um problema. Sem especifica√ß√µes claras, podemos encontrar partes do c√≥digo repetidas, aumentando a complexidade e o tempo de manuten√ß√£o, principalmente pela falta de clareza e ado√ß√£o do princ√≠pio [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself).

E quanto ao **aumento de bugs**? Isso pode ocorrer quando h√° falhas de comunica√ß√£o e as especifica√ß√µes n√£o s√£o compreendidas corretamente. Mas principalmente ocorrem pela **aus√™ncia de testes automatizados** para validar os comportamentos que s√£o esperados pelo software.

_**Como muitos lidam com esses problemas citados, quando se tornam insustent√°veis?**_

Os desenvolvedores podem considerar refatora√ß√µes significativas ou, em casos extremos, reescrever o software do zero. **Mas aten√ß√£o, essas s√£o medidas de curto prazo**. Se a equipe n√£o adotar um **plano consistente para controlar a entropia futura**, a deteriora√ß√£o do c√≥digo retornar√°. Mas o que tudo isso tem a ver com a teoria da janela quebrada?

# A teoria da janela quebrada

No livro [_**The Pragmatic Programmer**_](https://www.amazon.com.br/Pragmatic-Programmer-journey-mastery-Anniversary/dp/0135957052), os autores argumentam que a entropia do software √© contagiosa e, se n√£o for controlada, torna-se uma epidemia. Al√©m disso, fazem uma analogia com a teoria da janela quebrada. Vamos estudar isso mais afundo.

Proposta pelos criminologistas [_**James Wilson e George Kelling**_](https://www.britannica.com/topic/broken-windows-theory) e tendo um enorme impacto na pol√≠tica policial durante a d√©cada de 1990, a teoria das janelas quebradas √© uma ideia que sugere que a desordem f√≠sica em um ambiente urbano, como picha√ß√µes e vidra√ßas quebradas, pode levar a um aumento da criminalidade naquela √°rea ou degrada√ß√£o por v√¢ndalos no local.

Bom, voc√™ deve estar se perguntando, "Mas o que isso tem a ver com a entropia em software?" A resposta √©: muito mais do que voc√™ imagina!

Considere um c√≥digo com inconsist√™ncias, redund√¢ncias, bugs ou mesmo code smells. Cada um desses elementos pode ser visto como uma "janela quebrada" na engenharia de software. Deix√°-los sem solu√ß√£o, ou pior, **permitir que se acumulem**, gera uma crescente desordem - ou seja, a entropia do software. Essa alta entropia faz com que o c√≥digo se torne cada vez mais dif√≠cil de manter, entender e evoluir.

De maneira similar √† [_Teoria da Janela Quebrada_](https://www.britannica.com/topic/broken-windows-theory), um c√≥digo mal cuidado e desorganizado pode incentivar pr√°ticas ruins de programa√ß√£o. Imagine que um novo membro da equipe se depara com um c√≥digo repleto de inconsist√™ncias e bugs. Se n√£o houver um esfor√ßo consciente para manter a qualidade do c√≥digo, esse novo membro pode ser levado a pensar: "_Se o c√≥digo j√° est√° nesse estado, por que eu deveria me esfor√ßar para escrever um c√≥digo de qualidade?_".

**A consequ√™ncia √© um ciclo vicioso, onde a qualidade do software se deteriora, a produtividade diminui, os bugs aumentam e a entropia se torna incontrol√°vel**. Assim como em uma casa de bairro onde as janelas quebradas n√£o s√£o consertadas, a desordem acaba por tomar conta.

Podemos acrescentar ainda mais, c√≥digos confusos sem documenta√ß√£o e **testes inadequados podem indicar aos desenvolvedores e gerentes de projeto que a qualidade n√£o √© uma prioridade, levando a comportamentos e decis√µes inadequadas para o contexto**. Isso pode incluir a adi√ß√£o de novos recursos sem levar em conta a manuten√ß√£o, omitir refatora√ß√µes necess√°rias e n√£o monitorar a qualidade do c√≥digo. Esses comportamentos inadequados podem levar a um efeito domin√≥ de problemas, onde a entropia do c√≥digo aumenta gradualmente.

> A rela√ß√£o entre a Teoria da Janela Quebrada e a entropia √© esta: ambos s√£o formas de entender a import√¢ncia da manuten√ß√£o cont√≠nua e do cuidado com os detalhes. Tanto em uma cidade quanto em um sistema de software, a desordem se instala quando permitimos que pequenos problemas se acumulem. E a maneira de combater isso √© atrav√©s do cuidado constante, da manuten√ß√£o regular e da aten√ß√£o aos detalhes.

# Como tratar esse problema grave?

A _primeira_ coisa a se ter em mente √© que **qualidade e manuten√ß√£o n√£o s√£o aspectos a serem considerados apenas no final** de um projeto - eles devem estar presentes desde o in√≠cio. Pare de pensar que testes e refatora√ß√µes s√£o perdas de tempo!

_Segundo_, **mantenha a comunica√ß√£o**. Parece simples, mas √© crucial. √â necess√°rio que _**todos**_ os membros da equipe, sejam desenvolvedores, gerentes, propriet√°rios de produtos ou outras partes interessadas, estejam alinhados em termos de requisitos, prazos e objetivos. Dessa forma, podemos reduzir mal-entendidos e evitar inconsist√™ncias que contribuem para a entropia.

_Terceiro_, **ter uma pol√≠tica de c√≥digo limpo e seguir as melhores pr√°ticas de codifica√ß√£o**. Aqui entram padr√µes de codifica√ß√£o consistentes, revis√µes de c√≥digo, testes automatizados e uma atitude proativa em rela√ß√£o √† refatora√ß√£o. N√£o se trata apenas de escrever c√≥digo que funciona, mas de escrever c√≥digo que outros possam entender e manter.

_Quarto_, devemos **prestar aten√ß√£o √† arquitetura do nosso software**. Uma arquitetura bem planejada e escal√°vel reduz a probabilidade de termos que realizar mudan√ßas dr√°sticas no futuro, que podem introduzir novos bugs e aumentar a complexidade e a entropia. Uma arquitetura planejada de maneira precipitada leva a complexidade desnecess√°ria e a um conflitos de ideias entre desenvolvedores dentro do projeto.

Por fim, **a gest√£o eficaz das mudan√ßas**. Mudan√ßas _**s√£o inevit√°veis**_ em qualquer projeto, mas a maneira como lidamos com elas pode fazer uma grande diferen√ßa. Uma abordagem √°gil, que encoraja o feedback cont√≠nuo e a adapta√ß√£o, pode ajudar a gerir as mudan√ßas de uma forma que reduza a entropia ao inv√©s de aument√°-la.

Cada janela quebrada que consertamos √© um passo na dire√ß√£o certa. Cada bug corrigido, cada inconsist√™ncia eliminada, cada "cheiro de c√≥digo" resolvido contribui para o controle da entropia. E, ao manter a entropia sob controle, garantimos que nosso software seja sustent√°vel, escal√°vel, test√°vel, compreendido e, acima de tudo, um f√°cil de modificar e trabalhar.

# Como os testes ajudam a manter a entropia sobre controle?

Os testes **continuam sendo uma ferramenta subestimada por muitos desenvolvedores na luta contra a alta entropia no software**. Por que? J√° tentou montar um quebra-cabe√ßas sem a imagem de refer√™ncia? Bem, se voc√™ j√° o fez, sabe o qu√£o complicado √© montar a imagem. Testes, meus caros leitores, s√£o como essa imagem de refer√™ncia na constru√ß√£o do nosso grande quebra-cabe√ßas de software. Sem uma imagem clara do sistema, n√£o podemos saber exatamente o que um software faz, ou seja, seu prop√≥sito. Seus principais recursos e objetivos. **Testes refletem os comportamentos do software, s√£o um espelho do software, que podemos executar e entender pelo que cada peda√ßo de c√≥digo √© respons√°vel**!

Os testes de software, unit√°rios, de integra√ß√£o, funcional, de stress, entre outros, t√™m um papel crucial na preven√ß√£o e controle da entropia do software. Como exatamente?

1. **Detectando problemas mais cedo**: Testes bem escritos ajudam a identificar bugs, inconsist√™ncias e falhas mais cedo, quando eles s√£o mais f√°ceis (e mais baratos) de serem corrigidos. Testes automatizados executados regularmente garantem que qualquer "janela quebrada" seja prontamente detectada, evitando a propaga√ß√£o da entropia.
2. **Prevenindo a regress√£o**: √Ä medida que o software evolui, √© f√°cil quebrar funcionalidades existentes sem perceber. Com uma su√≠te de testes abrangente, voc√™ tem uma rede de seguran√ßa que ajuda a prevenir esses problemas, garantindo que o software continue funcionando como esperado ap√≥s cada mudan√ßa.
3. **Documenta√ß√£o viva**: Testes s√£o uma esp√©cie de documenta√ß√£o viva do sistema, que descreve como ele deve funcionar. Ao consultar os testes, _**novos membros da equipe ou mesmo desenvolvedores veteranos podem entender melhor o c√≥digo**_, mantendo a base de c√≥digo consistente e minimizando a entropia.
4. **Melhora a qualidade do c√≥digo**: Testes incentivam os desenvolvedores a escreverem c√≥digos mais modulares e independentes (f√°ceis de testar), o que por si s√≥ j√° contribui para reduzir a entropia.
5. **Fornece confian√ßa para refatorar** : Melhorar seu design sem alterar seu comportamento √© uma atividade necess√°ria para manter a entropia controlada. Testes fornecem a seguran√ßa de que, se algo quebrar durante a refatora√ß√£o, ser√° prontamente detectado.

No livro que estou escrevendo que pretendo _**anunciar o nome em breve**_, falo sobre esses pontos de uma perspectiva mais pr√°tica para a ind√∫stria de software. Realmente quando levamos muito a s√©rio os testes, temos ganhos significativos de produtividade no dia a dia ao programar novos recursos e manter os que j√° existem. Obviamente n√£o √© uma tarefa simples, existem desafios e principalmente compromisso com a qualidade.

Em conclus√£o, a Teoria da Janela Quebrada nos ensina que a toler√¢ncia a pequenas falhas ou "janelas quebradas" no nosso c√≥digo pode levar a uma cascata de problemas. Os desenvolvedores podem come√ßar a achar que √© aceit√°vel produzir c√≥digo de baixa qualidade, ou ignorar os testes, aumentando assim a entropia. Ao abra√ßar boas pr√°ticas e manter um olhar atento para "janelas quebradas", podemos manter a entropia sob controle e assegurar que nossos projetos de software permane√ßam saud√°veis e sustent√°veis.

Novamente, √© mais f√°cil escrever do que colocar em pr√°tica, por isso estou centralizando em um livro esse tema para abordar com mais liberdade e profundidade esse assunto t√£o complexo e interessante que faz parte do nosso cotidiano.

Fico por aqui. Espero que tenham gostado! Muito obrigada pela leitura at√© o final, espero que as dicas possam ajudar no dia a dia! At√© o pr√≥ximo artigo! üòÑüñêÔ∏è
